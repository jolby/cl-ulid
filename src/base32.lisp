;; (ql:quickload '(:serapeum :cl+ssl :secure-random))

(defpackage :ulid
  (:use :cl)
  (:export
   #:encode-timestamp
   #:encode-randomness
   #:encode
   #:decode-timestamp
   #:decode-randomness
   #:decode))

(in-package :ulid)

(defconstant +timestamp-len+ 6)
(defconstant +randomness-len+ 10)
(defconstant +bytes-len+ (+ +timestamp-len+ +randomness-len+))

(defconstant +timestamp-repr-len+ 10)
(defconstant +randomness-repr-len+ 16)
(defconstant +repr-len+ (+ +timestamp-repr-len+ +randomness-repr-len+))

(defparameter *encode* "0123456789ABCDEFGHJKMNPQRSTVWXYZ")

(defparameter *decode*
  #(255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
  255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255
  255 255 255 255 255 255 255 255 255 255 0 1 2 3 4 5 6 7 8 9 255 255 255 255
  255 255 255 10 11 12 13 14 15 16 17 255 18 19 255 20 21 255 22 23 24 25 26
  255 27 28 29 30 31 255 255 255 255 255 255 10 11 12 13 14 15 16 17 255 18 19
  255 20 21 255 22 23 24 25 26 255 27 28 29 30 31 255 255 255 255 255 255 255)
  "Char to index lookup array for massive speedup since we can find a char's
 index in O(1). We use 255 as 'sentinel' value for invalid indexes. ")

(defun encode-timestamp (binary)
  (unless (= (length binary) +timestamp-len+)
    (error "timestamp value has to be exactly 6 bytes long."))
  (let ((lut *encode*)
        (result (make-array 10)))
    (setf (aref result 0) (aref lut (ash (logand (aref binary 0) 224) -5)))
    (setf (aref result 1) (aref lut (logand (aref binary 0) 31)))
    (setf (aref result 2) (aref lut (ash (logand (aref binary 1) 248) -3)))
    (setf (aref result 3) (aref lut (logior (ash (logand (aref binary 1) 7) 2)
                                            (ash (logand (aref binary 2) 192) -6))))
    (setf (aref result 4) (aref lut (ash (logand (aref binary 2) 62) -1)))
    (setf (aref result 5) (aref lut (logior (ash (logand (aref binary 2) 1) 4)
                                            (ash (logand (aref binary 3) 240) -4))))
    (setf (aref result 6) (aref lut (logior (ash (logand (aref binary 3) 15) 1)
                                            (ash (logand (aref binary 4) 128) -7))))
    (setf (aref result 7) (aref lut (ash (logand (aref binary 4) 124) -2)))
    (setf (aref result 8) (aref lut (logior (ash (logand (aref binary 4) 3) 3)
                                            (ash (logand (aref binary 5) 224) -5))))
    (setf (aref result 9) (aref lut (logand (aref binary 5) 31)))
    (values (coerce result 'string) result)))

(defun encode-randomness (binary)
  (unless (= (length binary) +randomness-len+)
    (error "Randomness value has to be exactly 10 bytes long"))
  (let ((lut *encode*)
        (result (make-array 16)))
    (setf (aref result 0) (aref lut (ash (logand (aref binary 0) 248) -3)))
    (setf (aref result 1) (aref lut (logior (ash (logand (aref binary 0) 7) 2)
                                            (ash (logand (aref binary 1) 192) -6))))
    (setf (aref result 2) (aref lut (ash (logand (aref binary 1) 62) -1)))
    (setf (aref result 3) (aref lut (logior (ash (logand (aref binary 1) 1) 4)
                                            (ash (logand (aref binary 2) 240) -4))))
    (setf (aref result 4) (aref lut (logior (ash (logand (aref binary 2) 15) 1)
                                            (ash (logand (aref binary 3) 128) -7))))
    (setf (aref result 5) (aref lut (ash (logand (aref binary 3) 124) -2)))
    (setf (aref result 6) (aref lut (logior (ash (logand (aref binary 3) 3) 3)
                                            (ash (logand (aref binary 4) 224) -5))))
    (setf (aref result 7) (aref lut (logand (aref binary 4) 31)))
    (setf (aref result 8) (aref lut (ash (logand (aref binary 5) 248) -3)))
    (setf (aref result 9) (aref lut (logior (ash (logand (aref binary 5) 7) 2)
                                            (ash (logand (aref binary 6) 192) -6))))
    (setf (aref result 10) (aref lut (ash (logand (aref binary 6) 62) -1)))
    (setf (aref result 11) (aref lut (logior (ash (logand (aref binary 6) 1) 4)
                                             (ash (logand (aref binary 7) 240) -4))))
    (setf (aref result 12) (aref lut (logior (ash (logand (aref binary 7) 15) 1)
                                             (ash (logand (aref binary 8) 128) -7))))
    (setf (aref result 13) (aref lut (ash (logand (aref binary 8) 124) -2)))
    (setf (aref result 14) (aref lut (logior (ash (logand (aref binary 8) 3) 3)
                                             (ash (logand (aref binary 9) 224) -5))))
    (setf (aref result 15) (aref lut (logand (aref binary 9) 31)))
    (values (coerce result 'string) result)))

(defun encode (binary)
  (unless (= (length binary) +bytes-len+)
    (error "ULID has to be exactly 16 bytes long"))
  (concatenate 'string
               (encode-timestamp (subseq binary 0 +timestamp-len+))
               (encode-randomness (subseq binary +timestamp-len+))))

(defun decode-timestamp (encoded)
  (if (not (= (length encoded) +timestamp-repr-len+))
      (error "ULID timestamp has to be exactly 10 characters long."))
  (let* ((lut *decode*)
         (enc-bytes (babel:string-to-octets encoded :encoding :ascii))
         (result (make-array 6)))
    (setf (aref result 0) (logand (logior (ash (aref lut (aref enc-bytes 0)) 5)
                                          (aref lut (aref enc-bytes 1)))
                                  #xFF))
    (setf (aref result 1) (logand (logior (ash (aref lut (aref enc-bytes 2)) 3)
                                          (ash (aref lut (aref enc-bytes 3)) -2))
                                  #xFF))
    (setf (aref result 2) (logand (logior (logior (ash (aref lut (aref enc-bytes 3)) 6)
                                                (ash (aref lut (aref enc-bytes 4)) 1))
                                           (ash (aref lut (aref enc-bytes 5)) -4))
                                  #xFF))
    (setf (aref result 3) (logand (logior (ash (aref lut (aref enc-bytes 5)) 4)
                                          (ash (aref lut (aref enc-bytes 6)) -1))
                                  #xFF))
    (setf (aref result 4) (logand (logior (logior (ash (aref lut (aref enc-bytes 6)) 7)
                                                (ash (aref lut (aref enc-bytes 7)) 2))
                                           (ash (aref lut (aref enc-bytes 8)) -3))
                                  #xFF))
    (setf (aref result 5) (logand (logior (ash (aref lut (aref enc-bytes 8)) 5)
                                          (aref lut (aref enc-bytes 9)))
                                  #xFF))
    result))

(defun decode-randomness (encoded)
  (unless (= (length encoded) +randomness-repr-len+)
    (log:error "encoded: ~a, length: ~a" encoded (length encoded))
      (error "ULID randomness has to be exactly 16 characters long."))
  (let* ((lut *decode*)
         (enc-bytes (babel:string-to-octets encoded :encoding :ascii))
         (result (make-array 10)))
    (setf (aref result 0) (logand (logior (ash (aref lut (aref enc-bytes 0)) 3)
                                          (ash (aref lut (aref enc-bytes 1)) -2))
                                  #xFF))
    (setf (aref result 1) (logand (logior (logior (ash (aref lut (aref enc-bytes 1)) 6)
                                                (ash (aref lut (aref enc-bytes 2)) 1))
                                           (ash (aref lut (aref enc-bytes 3)) -4))
                                  #xFF))
    (setf (aref result 2) (logand (logior (ash (aref lut (aref enc-bytes 3)) 4)
                                          (ash (aref lut (aref enc-bytes 4)) -1))
                                  #xFF))
    (setf (aref result 3) (logand (logior (logior (ash (aref lut (aref enc-bytes 4)) 7)
                                                (ash (aref lut (aref enc-bytes 5)) 2))
                                           (ash (aref lut (aref enc-bytes 6)) -3))
                                  #xFF))
    (setf (aref result 4) (logand (logior (ash (aref lut (aref enc-bytes 6)) 5)
                                          (aref lut (aref enc-bytes 7)))
                                  #xFF))
    (setf (aref result 5) (logand (logior (ash (aref lut (aref enc-bytes 8)) 3)
                                          (ash (aref lut (aref enc-bytes 9)) -2))
                                  #xFF))
    (setf (aref result 6) (logand (logior (logior (ash (aref lut (aref enc-bytes 9)) 6)
                                                (ash (aref lut (aref enc-bytes 10)) 1))
                                           (ash (aref lut (aref enc-bytes 11)) -4))
                                  #xFF))
    (setf (aref result 7) (logand (logior (ash (aref lut (aref enc-bytes 11)) 4)
                                          (ash (aref lut (aref enc-bytes 12)) -1))
                                  #xFF))
    (setf (aref result 8) (logand (logior (logior (ash (aref lut (aref enc-bytes 12)) 7)
                                                (ash (aref lut (aref enc-bytes 13)) 2))
                                           (ash (aref lut (aref enc-bytes 14)) -3))
                                  #xFF))
    (setf (aref result 9) (logand (logior (ash (aref lut (aref enc-bytes 14)) 5)
                                          (aref lut (aref enc-bytes 15)))
                                  #xFF))
    result))

(defun decode (encoded)
  (if (not (= (length encoded) +repr-len+))
      (error "Encoded ULID has to be exactly 26 characters long."))
  (let* ((timestamp-section (subseq encoded 0 +timestamp-repr-len+))
         (randomness-section (subseq encoded +timestamp-repr-len+)))
    (concatenate 'vector
                 (decode-timestamp timestamp-section)
                 (decode-randomness randomness-section))))

(defun vec-elts-equal (v1 v2)
  (loop for i from 0 below (length v1)
        always (= (aref v1 i) (aref v2 i))))

;; (encode-timestamp (vector 255 255 255 255 255 255))
;; (encode-timestamp (vector 255 255 255 255 255 255 125)) ==> error
;; (encode-randomness (vector 255 255 255 255 255 255 255 255 255 125))
;; (encode-timestamp (crypto:random-data 6))
;; (defparameter *rand-6* (crypto:random-data 6))
;; (defparameter *rand-6-enc* (encode-timestamp *rand-6*))
;; (coerce *rand-6-enc* '(vector (unsigned-byte 8)))
;; (babel:string-to-octets *rand-6-enc* :encoding :ascii)
;; (length (vector 255 255 255 255 255 255))

#+(or) (let* ((encode-ts (encode-timestamp (crypto:random-data 6)))
             (decode-ts (decode-timestamp encode-ts)))
         (assert (equal (coerce (crypto:random-data 6) 'string)
                        (coerce decode-ts 'string))))
#+(or)(progn
        (loop :for i :below 1000
              :do (let* ((rand-6-bytes (crypto:random-data 6))
                         (lisp-encode (encode-timestamp rand-6-bytes))
                         (py-encode (ulid-py::ulid-py-encode-timestamp rand-6-bytes)))
                    (assert (equal lisp-encode py-encode))))
        (log:info "encode-timestamp test passed."))

#+(or)(progn
        (loop :for i :below 1000
              :do (let* ((rand-10-bytes (crypto:random-data 10))
                         (lisp-encode (encode-randomness rand-10-bytes))
                         (py-encode (ulid-py::ulid-py-encode-randomness rand-10-bytes)))
                    (assert (equal lisp-encode py-encode))))
        (log:info "encode-randomness test passed."))

#+(or)(progn
        (loop :for i :below 1000
              :do (let* ((rand-16-bytes (crypto:random-data 16))
                         (lisp-encode (encode rand-16-bytes))
                         (py-encode (ulid-py::ulid-py-encode rand-16-bytes)))
                    (assert (equal lisp-encode py-encode))))
        (log:info "encode test passed."))

#+(or)(progn
        (loop :for i :below 1000
              :do (let* ((rand-16-bytes (crypto:random-data 16))
                         (lisp-encode (encode rand-16-bytes))
                         (lisp-decode (decode lisp-encode)))
                    (assert (vec-elts-equal rand-16-bytes lisp-decode))))
        (log:info "encode/decode test passed."))
